% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/case_boot_loess.R
\name{case_boot_loess}
\alias{case_boot_loess}
\title{case_boot_loess: run case bootstrap for loess smoother and return model output}
\usage{
case_boot_loess(
  df,
  x = "cycle",
  y = NA,
  ID = "Plot_Name",
  group = NA,
  span = NA_real_,
  degree = 1,
  num_reps = NA,
  chatty = TRUE
)
}
\arguments{
\item{df}{Data frame containing a column called Plot_Name, a column called cycle, and a column with at least one
response variable.}

\item{x}{Quoted time variable for trend analysis. Default is "cycle", but can also model by year. Must be numeric.}

\item{y}{Quoted response variable in the data frame.}

\item{ID}{Quoted name of column containing site or plot IDs. Default is "Plot_Name", and assumes the first 4 characters
are a park code.}

\item{group}{Quote column containing a grouping variable, like "Unit_ID" for printing progress to console. If not specified,
will print the first 4 characters of the ID to the console, assuming the ID starts with a 4-letter park code.}

\item{span}{numeric value that controls the degree of smoothing. Smaller values (e.g., 0.1) result in less smoothing,
and possibly over-fitting the curve. Higher values (e.g., 0.9) result is more smoothing and possibly under-fitting.
You can calculate the number of time steps to include in the smoothing window by dividing p/n, where p is number of panels
you want to be included per window and n is number of timesteps in the data. When plotting years, knowing that panels include
4 years, it is generally safe to assume a linear response between 2 full cycles, and therefore use a span of 8/n. Note that
if you specify degree = 1, then loess assumes a linear relationship within each span. If no span is specified, then
fANCOVA::loess.as() will be used to determine the optimum span (Note: user specified is preferred).}

\item{degree}{order of polynomial to fit. Values of 1 (Default) is linear, 2 is quadratic, etc. Degrees of 1 or 2 are
generally recommended, depending on how wavy the line should to be.}

\item{num_reps}{Number of replicates to run in the bootstrap}

\item{chatty}{TRUE or FALSE. TRUE (default) will print progress in the console, including the first four characters
in the Plot_Name and a tick for every other replicate of the bootstrap. FALSE will not print progress in console.}
}
\description{
For each replicate, as specified by num_reps, function will generate a bootstrapped sample of data from the
original dataset, fit a loess model, and return the predicted values for mean response of each unique time step in the x variable,
along with 95 % confidence intervals for each of unique time step. The num_boots column is the number of bootstrapped samples
that successfully fit a loess model.
}
\examples{
\dontrun{

#----- Dataset with 1 park -----
fake_df <- data.frame(Plot_Name = rep(paste0(rep("PARK.", 9), 1:9), each = 3),
                      cycle = rep(1:3, times = 9),
                      resp = runif(27, 0, 20))

boot1 <- case_boot_loess(fake_df, y = "resp", num_reps = 10, span = 0.9, chatty = TRUE)

#----- Dataset with 2 parks iterating through each park with purrr -----
# Create fake dataset
library(tidyverse)
fake_2pk <- data.frame(Plot_Name = c(rep(paste0(rep("APRK-", 12), sprintf("\%02d", 1:12)), each = 3),
                       rep(paste0(rep("BPRK-", 12), sprintf("\%02d", 13:24)), each = 3)),
                       park = c(rep("APRK", 36), rep("BPRK", 36)),
                       cycle = rep(1:3, times = 24),
                       resp = runif(72, 0, 30))

# Nest dataset by park
nested_df <- fake_2pk \%>\% mutate(grp = park) \%>\% group_by(park) \%>\% nest()

# Run case_boot_loess on nested dataset
boot2 <- nested_df \%>\% mutate(
  model = map(data, ~case_boot_loess(., x = "cycle", y = "resp", ID = "Plot_Name",
                                    span = 0.95, group = "grp",
                                    num_reps = 100, chatty = TRUE)))

# Compile results
boot_results <- boot2 \%>\% select(park, model) \%>\% unnest(model)


}

}
